#include "browser-panel-client.hpp"
#include <util/dstr.h>
#include <obs-frontend-api.h>

#include <QUrl>
#include <QDesktopServices>
#include <QKeyEvent>
#include <QMainWindow>
#include <QCoreApplication>

#ifdef _WIN32
#include <windows.h>
#endif

#ifdef _WIN32
static void ForwardCefKeyEvent(const CefKeyEvent &event, QWidget* widget)
{
	if (!widget)
		return;

	/* We are only interested in key down and key up events */
	if (event.type != KEYEVENT_RAWKEYDOWN && event.type != KEYEVENT_KEYUP)
		return;

	/* We are not interested in system key events */
	//if (event.is_system_key)
	//	return;

	/* Is it a key press event? */
	bool pressed = event.type == KEYEVENT_KEYDOWN ||
		       event.type == KEYEVENT_RAWKEYDOWN;

	/* Bit 30 - the previous key state
	 * https://docs.microsoft.com/en-us/windows/desktop/inputdev/wm-syskeydown
	 *
	 * If this bit is set, it means that the key press event was
	 * generated by the auto-repeat keystroke function of the OS.
	 */
	bool repeated = !!((event.native_key_code >> 30) & 1);

	if (pressed && repeated) {
		/* We are not interested in pressed key auto-repeats */
		return;
	}

	int virtualKeyCode = event.windows_key_code;

	/* Translate virtual key code to Qt key code */
	struct mod_map_t {
		BYTE virtualKey;
		Qt::KeyboardModifiers qtModifier;
	};

	static const mod_map_t mods_map_pressed[] = {
		{VK_SHIFT, Qt::ShiftModifier},
		{VK_CONTROL, Qt::ControlModifier},
		{VK_MENU, Qt::AltModifier},
	};

	Qt::KeyboardModifiers modifiers = 0;

	/* Apply pressed modifier keys according to modifier map above
	 */
	for (auto &map_item : mods_map_pressed) {
		if (map_item.virtualKey != 0 &&
		    map_item.virtualKey != virtualKeyCode) {
			/* Get modifier key state from the OS */
			SHORT keyState =
				::GetAsyncKeyState(map_item.virtualKey);

			if (keyState != 0) {
				/* Modifier key is pressed, add a
				 * corresponding Qt-native modifier
				 * key flag */
				modifiers |= map_item.qtModifier;
			}
		}
	}

	QKeyEvent *qtKeyEvent =
		new QKeyEvent(pressed ? QEvent::KeyPress : QEvent::KeyRelease, virtualKeyCode,
		modifiers, event.native_key_code, virtualKeyCode, event.modifiers);

	QCoreApplication::instance()->postEvent(
		(QMainWindow *)obs_frontend_get_main_window(), qtKeyEvent);

	//QCoreApplication::instance()->postEvent(
	//	widget, qtKeyEvent);
}
#endif

/* CefClient */
CefRefPtr<CefLoadHandler> QCefBrowserClient::GetLoadHandler()
{
	return this;
}

CefRefPtr<CefDisplayHandler> QCefBrowserClient::GetDisplayHandler()
{
	return this;
}

CefRefPtr<CefRequestHandler> QCefBrowserClient::GetRequestHandler()
{
	return this;
}

CefRefPtr<CefLifeSpanHandler> QCefBrowserClient::GetLifeSpanHandler()
{
	return this;
}

CefRefPtr<CefKeyboardHandler> QCefBrowserClient::GetKeyboardHandler()
{
	return this;
}

/* CefDisplayHandler */
void QCefBrowserClient::OnTitleChange(CefRefPtr<CefBrowser> browser,
				      const CefString &title)
{
	if (widget && widget->cefBrowser->IsSame(browser)) {
		std::string str_title = title;
		QString qt_title = QString::fromUtf8(str_title.c_str());
		QMetaObject::invokeMethod(widget, "titleChanged",
					  Q_ARG(QString, qt_title));
	} else { /* handle popup title */
#ifdef _WIN32
		std::wstring str_title = title;
		HWND hwnd = browser->GetHost()->GetWindowHandle();
		SetWindowTextW(hwnd, str_title.c_str());
#endif
	}
}

/* CefRequestHandler */
bool QCefBrowserClient::OnBeforeBrowse(CefRefPtr<CefBrowser> browser,
				       CefRefPtr<CefFrame>,
				       CefRefPtr<CefRequest> request, bool,
				       bool)
{
	std::string str_url = request->GetURL();

	std::lock_guard<std::mutex> lock(popup_whitelist_mutex);
	for (size_t i = forced_popups.size(); i > 0; i--) {
		PopupWhitelistInfo &info = forced_popups[i - 1];

		if (!info.obj) {
			forced_popups.erase(forced_popups.begin() + (i - 1));
			continue;
		}

		if (astrcmpi(info.url.c_str(), str_url.c_str()) == 0) {
			/* Open tab popup URLs in user's actual browser */
			QUrl url = QUrl(str_url.c_str(), QUrl::TolerantMode);
			QDesktopServices::openUrl(url);
			browser->GoBack();
			return true;
		}
	}

	if (widget) {
		QString qt_url = QString::fromUtf8(str_url.c_str());
		QMetaObject::invokeMethod(widget, "urlChanged",
					  Q_ARG(QString, qt_url));
	}
	return false;
}

bool QCefBrowserClient::OnOpenURLFromTab(
	CefRefPtr<CefBrowser>, CefRefPtr<CefFrame>, const CefString &target_url,
	CefRequestHandler::WindowOpenDisposition, bool)
{
	std::string str_url = target_url;

	/* Open tab popup URLs in user's actual browser */
	QUrl url = QUrl(str_url.c_str(), QUrl::TolerantMode);
	QDesktopServices::openUrl(url);
	return true;
}

/* CefLifeSpanHandler */
bool QCefBrowserClient::OnBeforePopup(
	CefRefPtr<CefBrowser>, CefRefPtr<CefFrame>, const CefString &target_url,
	const CefString &, CefLifeSpanHandler::WindowOpenDisposition, bool,
	const CefPopupFeatures &, CefWindowInfo &windowInfo,
	CefRefPtr<CefClient> &, CefBrowserSettings &,
#if CHROME_VERSION_BUILD >= 3770
	CefRefPtr<CefDictionaryValue> &,
#endif
	bool *)
{
	if (allowAllPopups) {
#ifdef _WIN32
		HWND hwnd = (HWND)widget->effectiveWinId();
		windowInfo.parent_window = hwnd;
#endif
		return false;
	}

	std::string str_url = target_url;

	std::lock_guard<std::mutex> lock(popup_whitelist_mutex);
	for (size_t i = popup_whitelist.size(); i > 0; i--) {
		PopupWhitelistInfo &info = popup_whitelist[i - 1];

		if (!info.obj) {
			popup_whitelist.erase(popup_whitelist.begin() +
					      (i - 1));
			continue;
		}

		if (astrcmpi(info.url.c_str(), str_url.c_str()) == 0) {
#ifdef _WIN32
			HWND hwnd = (HWND)widget->effectiveWinId();
			windowInfo.parent_window = hwnd;
#endif
			return false;
		}
	}

	/* Open popup URLs in user's actual browser */
	QUrl url = QUrl(str_url.c_str(), QUrl::TolerantMode);
	QDesktopServices::openUrl(url);
	return true;
}

void QCefBrowserClient::OnLoadEnd(CefRefPtr<CefBrowser>,
				  CefRefPtr<CefFrame> frame, int)
{
	if (frame->IsMain() && !script.empty())
		frame->ExecuteJavaScript(script, CefString(), 0);
}

bool QCefBrowserClient::OnPreKeyEvent(CefRefPtr<CefBrowser> browser,
				      const CefKeyEvent &event, CefEventHandle,
				      bool *)
{
#ifdef _WIN32
	ForwardCefKeyEvent(event, widget);
#endif

#ifdef _WIN32
	if (event.type != KEYEVENT_RAWKEYDOWN)
		return false;

	if (event.windows_key_code == 'R' &&
	    (event.modifiers & EVENTFLAG_CONTROL_DOWN) != 0) {
		browser->ReloadIgnoreCache();
		return true;
	}
#endif
	return false;
}
